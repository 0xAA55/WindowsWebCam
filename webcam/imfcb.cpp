#include "imfcb.hpp"

#include <mutex>

#include <locale>
#include <codecvt>

namespace WindowsWebCamTypeLib
{
	bool CoInitCalled = false;

	static std::string FH(HRESULT hr)
	{
		switch (hr)
		{
		case MF_E_PLATFORM_NOT_INITIALIZED: return "MF_E_PLATFORM_NOT_INITIALIZED(0xC00D36B0L)";
		case MF_E_BUFFERTOOSMALL: return "MF_E_BUFFERTOOSMALL(0xC00D36B1L)";
		case MF_E_INVALIDREQUEST: return "MF_E_INVALIDREQUEST(0xC00D36B2L)";
		case MF_E_INVALIDSTREAMNUMBER: return "MF_E_INVALIDSTREAMNUMBER(0xC00D36B3L)";
		case MF_E_INVALIDMEDIATYPE: return "MF_E_INVALIDMEDIATYPE(0xC00D36B4L)";
		case MF_E_NOTACCEPTING: return "MF_E_NOTACCEPTING(0xC00D36B5L)";
		case MF_E_NOT_INITIALIZED: return "MF_E_NOT_INITIALIZED(0xC00D36B6L)";
		case MF_E_UNSUPPORTED_REPRESENTATION: return "MF_E_UNSUPPORTED_REPRESENTATION(0xC00D36B7L)";
		case MF_E_NO_MORE_TYPES: return "MF_E_NO_MORE_TYPES(0xC00D36B9L)";
		case MF_E_UNSUPPORTED_SERVICE: return "MF_E_UNSUPPORTED_SERVICE(0xC00D36BAL)";
		case MF_E_UNEXPECTED: return "MF_E_UNEXPECTED(0xC00D36BBL)";
		case MF_E_INVALIDNAME: return "MF_E_INVALIDNAME(0xC00D36BCL)";
		case MF_E_INVALIDTYPE: return "MF_E_INVALIDTYPE(0xC00D36BDL)";
		case MF_E_INVALID_FILE_FORMAT: return "MF_E_INVALID_FILE_FORMAT(0xC00D36BEL)";
		case MF_E_INVALIDINDEX: return "MF_E_INVALIDINDEX(0xC00D36BFL)";
		case MF_E_INVALID_TIMESTAMP: return "MF_E_INVALID_TIMESTAMP(0xC00D36C0L)";
		case MF_E_UNSUPPORTED_SCHEME: return "MF_E_UNSUPPORTED_SCHEME(0xC00D36C3L)";
		case MF_E_UNSUPPORTED_BYTESTREAM_TYPE: return "MF_E_UNSUPPORTED_BYTESTREAM_TYPE(0xC00D36C4L)";
		case MF_E_UNSUPPORTED_TIME_FORMAT: return "MF_E_UNSUPPORTED_TIME_FORMAT(0xC00D36C5L)";
		case MF_E_NO_SAMPLE_TIMESTAMP: return "MF_E_NO_SAMPLE_TIMESTAMP(0xC00D36C8L)";
		case MF_E_NO_SAMPLE_DURATION: return "MF_E_NO_SAMPLE_DURATION(0xC00D36C9L)";
		case MF_E_INVALID_STREAM_DATA: return "MF_E_INVALID_STREAM_DATA(0xC00D36CBL)";
		case MF_E_RT_UNAVAILABLE: return "MF_E_RT_UNAVAILABLE(0xC00D36CFL)";
		case MF_E_UNSUPPORTED_RATE: return "MF_E_UNSUPPORTED_RATE(0xC00D36D0L)";
		case MF_E_THINNING_UNSUPPORTED: return "MF_E_THINNING_UNSUPPORTED(0xC00D36D1L)";
		case MF_E_REVERSE_UNSUPPORTED: return "MF_E_REVERSE_UNSUPPORTED(0xC00D36D2L)";
		case MF_E_UNSUPPORTED_RATE_TRANSITION: return "MF_E_UNSUPPORTED_RATE_TRANSITION(0xC00D36D3L)";
		case MF_E_RATE_CHANGE_PREEMPTED: return "MF_E_RATE_CHANGE_PREEMPTED(0xC00D36D4L)";
		case MF_E_NOT_FOUND: return "MF_E_NOT_FOUND(0xC00D36D5L)";
		case MF_E_NOT_AVAILABLE: return "MF_E_NOT_AVAILABLE(0xC00D36D6L)";
		case MF_E_NO_CLOCK: return "MF_E_NO_CLOCK(0xC00D36D7L)";
		case MF_S_MULTIPLE_BEGIN: return "MF_S_MULTIPLE_BEGIN(0x000D36D8L)";
		case MF_E_MULTIPLE_BEGIN: return "MF_E_MULTIPLE_BEGIN(0xC00D36D9L)";
		case MF_E_MULTIPLE_SUBSCRIBERS: return "MF_E_MULTIPLE_SUBSCRIBERS(0xC00D36DAL)";
		case MF_E_TIMER_ORPHANED: return "MF_E_TIMER_ORPHANED(0xC00D36DBL)";
		case MF_E_STATE_TRANSITION_PENDING: return "MF_E_STATE_TRANSITION_PENDING(0xC00D36DCL)";
		case MF_E_UNSUPPORTED_STATE_TRANSITION: return "MF_E_UNSUPPORTED_STATE_TRANSITION(0xC00D36DDL)";
		case MF_E_UNRECOVERABLE_ERROR_OCCURRED: return "MF_E_UNRECOVERABLE_ERROR_OCCURRED(0xC00D36DEL)";
		case MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS: return "MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS(0xC00D36DFL)";
		case MF_E_SAMPLE_NOT_WRITABLE: return "MF_E_SAMPLE_NOT_WRITABLE(0xC00D36E0L)";
		case MF_E_INVALID_KEY: return "MF_E_INVALID_KEY(0xC00D36E2L)";
		case MF_E_BAD_STARTUP_VERSION: return "MF_E_BAD_STARTUP_VERSION(0xC00D36E3L)";
		case MF_E_UNSUPPORTED_CAPTION: return "MF_E_UNSUPPORTED_CAPTION(0xC00D36E4L)";
		case MF_E_INVALID_POSITION: return "MF_E_INVALID_POSITION(0xC00D36E5L)";
		case MF_E_ATTRIBUTENOTFOUND: return "MF_E_ATTRIBUTENOTFOUND(0xC00D36E6L)";
		case MF_E_PROPERTY_TYPE_NOT_ALLOWED: return "MF_E_PROPERTY_TYPE_NOT_ALLOWED(0xC00D36E7L)";
		case MF_E_PROPERTY_TYPE_NOT_SUPPORTED: return "MF_E_PROPERTY_TYPE_NOT_SUPPORTED(0xC00D36E8L)";
		case MF_E_PROPERTY_EMPTY: return "MF_E_PROPERTY_EMPTY(0xC00D36E9L)";
		case MF_E_PROPERTY_NOT_EMPTY: return "MF_E_PROPERTY_NOT_EMPTY(0xC00D36EAL)";
		case MF_E_PROPERTY_VECTOR_NOT_ALLOWED: return "MF_E_PROPERTY_VECTOR_NOT_ALLOWED(0xC00D36EBL)";
		case MF_E_PROPERTY_VECTOR_REQUIRED: return "MF_E_PROPERTY_VECTOR_REQUIRED(0xC00D36ECL)";
		case MF_E_OPERATION_CANCELLED: return "MF_E_OPERATION_CANCELLED(0xC00D36EDL)";
		case MF_E_BYTESTREAM_NOT_SEEKABLE: return "MF_E_BYTESTREAM_NOT_SEEKABLE(0xC00D36EEL)";
		case MF_E_DISABLED_IN_SAFEMODE: return "MF_E_DISABLED_IN_SAFEMODE(0xC00D36EFL)";
		case MF_E_CANNOT_PARSE_BYTESTREAM: return "MF_E_CANNOT_PARSE_BYTESTREAM(0xC00D36F0L)";
		case MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS: return "MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS(0xC00D36F1L)";
		case MF_E_MEDIAPROC_WRONGSTATE: return "MF_E_MEDIAPROC_WRONGSTATE(0xC00D36F2L)";
		case MF_E_RT_THROUGHPUT_NOT_AVAILABLE: return "MF_E_RT_THROUGHPUT_NOT_AVAILABLE(0xC00D36F3L)";
		case MF_E_RT_TOO_MANY_CLASSES: return "MF_E_RT_TOO_MANY_CLASSES(0xC00D36F4L)";
		case MF_E_RT_WOULDBLOCK: return "MF_E_RT_WOULDBLOCK(0xC00D36F5L)";
		case MF_E_NO_BITPUMP: return "MF_E_NO_BITPUMP(0xC00D36F6L)";
		case MF_E_RT_OUTOFMEMORY: return "MF_E_RT_OUTOFMEMORY(0xC00D36F7L)";
		case MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED: return "MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED(0xC00D36F8L)";
		case MF_E_INSUFFICIENT_BUFFER: return "MF_E_INSUFFICIENT_BUFFER(0xC00D7170L)";
		case MF_E_CANNOT_CREATE_SINK: return "MF_E_CANNOT_CREATE_SINK(0xC00D36FAL)";
		case MF_E_BYTESTREAM_UNKNOWN_LENGTH: return "MF_E_BYTESTREAM_UNKNOWN_LENGTH(0xC00D36FBL)";
		case MF_E_SESSION_PAUSEWHILESTOPPED: return "MF_E_SESSION_PAUSEWHILESTOPPED(0xC00D36FCL)";
		case MF_S_ACTIVATE_REPLACED: return "MF_S_ACTIVATE_REPLACED(0x000D36FDL)";
		case MF_E_FORMAT_CHANGE_NOT_SUPPORTED: return "MF_E_FORMAT_CHANGE_NOT_SUPPORTED(0xC00D36FEL)";
		case MF_E_INVALID_WORKQUEUE: return "MF_E_INVALID_WORKQUEUE(0xC00D36FFL)";
		case MF_E_DRM_UNSUPPORTED: return "MF_E_DRM_UNSUPPORTED(0xC00D3700L)";
		case MF_E_UNAUTHORIZED: return "MF_E_UNAUTHORIZED(0xC00D3701L)";
		case MF_E_OUT_OF_RANGE: return "MF_E_OUT_OF_RANGE(0xC00D3702L)";
		case MF_E_INVALID_CODEC_MERIT: return "MF_E_INVALID_CODEC_MERIT(0xC00D3703L)";
		case MF_E_HW_MFT_FAILED_START_STREAMING: return "MF_E_HW_MFT_FAILED_START_STREAMING(0xC00D3704L)";
		case MF_E_OPERATION_IN_PROGRESS: return "MF_E_OPERATION_IN_PROGRESS(0xC00D3705L)";
		case MF_E_HARDWARE_DRM_UNSUPPORTED: return "MF_E_HARDWARE_DRM_UNSUPPORTED(0xC00D3706L)";
		case MF_E_DURATION_TOO_LONG: return "MF_E_DURATION_TOO_LONG(0xC00D3707L)";
		case MF_E_OPERATION_UNSUPPORTED_AT_D3D_FEATURE_LEVEL: return "MF_E_OPERATION_UNSUPPORTED_AT_D3D_FEATURE_LEVEL(0xC00D3708L)";
		case MF_E_UNSUPPORTED_MEDIATYPE_AT_D3D_FEATURE_LEVEL: return "MF_E_UNSUPPORTED_MEDIATYPE_AT_D3D_FEATURE_LEVEL(0xC00D3709L)";
		case MF_S_ASF_PARSEINPROGRESS: return "MF_S_ASF_PARSEINPROGRESS(0x400D3A98L)";
		case MF_E_ASF_PARSINGINCOMPLETE: return "MF_E_ASF_PARSINGINCOMPLETE(0xC00D3A98L)";
		case MF_E_ASF_MISSINGDATA: return "MF_E_ASF_MISSINGDATA(0xC00D3A99L)";
		case MF_E_ASF_INVALIDDATA: return "MF_E_ASF_INVALIDDATA(0xC00D3A9AL)";
		case MF_E_ASF_OPAQUEPACKET: return "MF_E_ASF_OPAQUEPACKET(0xC00D3A9BL)";
		case MF_E_ASF_NOINDEX: return "MF_E_ASF_NOINDEX(0xC00D3A9CL)";
		case MF_E_ASF_OUTOFRANGE: return "MF_E_ASF_OUTOFRANGE(0xC00D3A9DL)";
		case MF_E_ASF_INDEXNOTLOADED: return "MF_E_ASF_INDEXNOTLOADED(0xC00D3A9EL)";
		case MF_E_ASF_TOO_MANY_PAYLOADS: return "MF_E_ASF_TOO_MANY_PAYLOADS(0xC00D3A9FL)";
		case MF_E_ASF_UNSUPPORTED_STREAM_TYPE: return "MF_E_ASF_UNSUPPORTED_STREAM_TYPE(0xC00D3AA0L)";
		case MF_E_ASF_DROPPED_PACKET: return "MF_E_ASF_DROPPED_PACKET(0xC00D3AA1L)";
		case MF_E_NO_EVENTS_AVAILABLE: return "MF_E_NO_EVENTS_AVAILABLE(0xC00D3E80L)";
		case MF_E_INVALID_STATE_TRANSITION: return "MF_E_INVALID_STATE_TRANSITION(0xC00D3E82L)";
		case MF_E_END_OF_STREAM: return "MF_E_END_OF_STREAM(0xC00D3E84L)";
		case MF_E_SHUTDOWN: return "MF_E_SHUTDOWN(0xC00D3E85L)";
		case MF_E_MP3_NOTFOUND: return "MF_E_MP3_NOTFOUND(0xC00D3E86L)";
		case MF_E_MP3_OUTOFDATA: return "MF_E_MP3_OUTOFDATA(0xC00D3E87L)";
		case MF_E_MP3_NOTMP3: return "MF_E_MP3_NOTMP3(0xC00D3E88L)";
		case MF_E_MP3_NOTSUPPORTED: return "MF_E_MP3_NOTSUPPORTED(0xC00D3E89L)";
		case MF_E_NO_DURATION: return "MF_E_NO_DURATION(0xC00D3E8AL)";
		case MF_E_INVALID_FORMAT: return "MF_E_INVALID_FORMAT(0xC00D3E8CL)";
		case MF_E_PROPERTY_NOT_FOUND: return "MF_E_PROPERTY_NOT_FOUND(0xC00D3E8DL)";
		case MF_E_PROPERTY_READ_ONLY: return "MF_E_PROPERTY_READ_ONLY(0xC00D3E8EL)";
		case MF_E_PROPERTY_NOT_ALLOWED: return "MF_E_PROPERTY_NOT_ALLOWED(0xC00D3E8FL)";
		case MF_E_MEDIA_SOURCE_NOT_STARTED: return "MF_E_MEDIA_SOURCE_NOT_STARTED(0xC00D3E91L)";
		case MF_E_UNSUPPORTED_FORMAT: return "MF_E_UNSUPPORTED_FORMAT(0xC00D3E98L)";
		case MF_E_MP3_BAD_CRC: return "MF_E_MP3_BAD_CRC(0xC00D3E99L)";
		case MF_E_NOT_PROTECTED: return "MF_E_NOT_PROTECTED(0xC00D3E9AL)";
		case MF_E_MEDIA_SOURCE_WRONGSTATE: return "MF_E_MEDIA_SOURCE_WRONGSTATE(0xC00D3E9BL)";
		case MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED: return "MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED(0xC00D3E9CL)";
		case MF_E_CANNOT_FIND_KEYFRAME_SAMPLE: return "MF_E_CANNOT_FIND_KEYFRAME_SAMPLE(0xC00D3E9DL)";
		case MF_E_UNSUPPORTED_CHARACTERISTICS: return "MF_E_UNSUPPORTED_CHARACTERISTICS(0xC00D3E9EL)";
		case MF_E_NO_AUDIO_RECORDING_DEVICE: return "MF_E_NO_AUDIO_RECORDING_DEVICE(0xC00D3E9FL)";
		case MF_E_AUDIO_RECORDING_DEVICE_IN_USE: return "MF_E_AUDIO_RECORDING_DEVICE_IN_USE(0xC00D3EA0L)";
		case MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED: return "MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED(0xC00D3EA1L)";
		case MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED: return "MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED(0xC00D3EA2L)";
		case MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED: return "MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED(0xC00D3EA3L)";
		case MF_E_NETWORK_RESOURCE_FAILURE: return "MF_E_NETWORK_RESOURCE_FAILURE(0xC00D4268L)";
		case MF_E_NET_WRITE: return "MF_E_NET_WRITE(0xC00D4269L)";
		case MF_E_NET_READ: return "MF_E_NET_READ(0xC00D426AL)";
		case MF_E_NET_REQUIRE_NETWORK: return "MF_E_NET_REQUIRE_NETWORK(0xC00D426BL)";
		case MF_E_NET_REQUIRE_ASYNC: return "MF_E_NET_REQUIRE_ASYNC(0xC00D426CL)";
		case MF_E_NET_BWLEVEL_NOT_SUPPORTED: return "MF_E_NET_BWLEVEL_NOT_SUPPORTED(0xC00D426DL)";
		case MF_E_NET_STREAMGROUPS_NOT_SUPPORTED: return "MF_E_NET_STREAMGROUPS_NOT_SUPPORTED(0xC00D426EL)";
		case MF_E_NET_MANUALSS_NOT_SUPPORTED: return "MF_E_NET_MANUALSS_NOT_SUPPORTED(0xC00D426FL)";
		case MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR: return "MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR(0xC00D4270L)";
		case MF_E_NET_CACHESTREAM_NOT_FOUND: return "MF_E_NET_CACHESTREAM_NOT_FOUND(0xC00D4271L)";
		case MF_I_MANUAL_PROXY: return "MF_I_MANUAL_PROXY(0x400D4272L)";
		case MF_E_NET_REQUIRE_INPUT: return "MF_E_NET_REQUIRE_INPUT(0xC00D4274L)";
		case MF_E_NET_REDIRECT: return "MF_E_NET_REDIRECT(0xC00D4275L)";
		case MF_E_NET_REDIRECT_TO_PROXY: return "MF_E_NET_REDIRECT_TO_PROXY(0xC00D4276L)";
		case MF_E_NET_TOO_MANY_REDIRECTS: return "MF_E_NET_TOO_MANY_REDIRECTS(0xC00D4277L)";
		case MF_E_NET_TIMEOUT: return "MF_E_NET_TIMEOUT(0xC00D4278L)";
		case MF_E_NET_CLIENT_CLOSE: return "MF_E_NET_CLIENT_CLOSE(0xC00D4279L)";
		case MF_E_NET_BAD_CONTROL_DATA: return "MF_E_NET_BAD_CONTROL_DATA(0xC00D427AL)";
		case MF_E_NET_INCOMPATIBLE_SERVER: return "MF_E_NET_INCOMPATIBLE_SERVER(0xC00D427BL)";
		case MF_E_NET_UNSAFE_URL: return "MF_E_NET_UNSAFE_URL(0xC00D427CL)";
		case MF_E_NET_CACHE_NO_DATA: return "MF_E_NET_CACHE_NO_DATA(0xC00D427DL)";
		case MF_E_NET_EOL: return "MF_E_NET_EOL(0xC00D427EL)";
		case MF_E_NET_BAD_REQUEST: return "MF_E_NET_BAD_REQUEST(0xC00D427FL)";
		case MF_E_NET_INTERNAL_SERVER_ERROR: return "MF_E_NET_INTERNAL_SERVER_ERROR(0xC00D4280L)";
		case MF_E_NET_SESSION_NOT_FOUND: return "MF_E_NET_SESSION_NOT_FOUND(0xC00D4281L)";
		case MF_E_NET_NOCONNECTION: return "MF_E_NET_NOCONNECTION(0xC00D4282L)";
		case MF_E_NET_CONNECTION_FAILURE: return "MF_E_NET_CONNECTION_FAILURE(0xC00D4283L)";
		case MF_E_NET_INCOMPATIBLE_PUSHSERVER: return "MF_E_NET_INCOMPATIBLE_PUSHSERVER(0xC00D4284L)";
		case MF_E_NET_SERVER_ACCESSDENIED: return "MF_E_NET_SERVER_ACCESSDENIED(0xC00D4285L)";
		case MF_E_NET_PROXY_ACCESSDENIED: return "MF_E_NET_PROXY_ACCESSDENIED(0xC00D4286L)";
		case MF_E_NET_CANNOTCONNECT: return "MF_E_NET_CANNOTCONNECT(0xC00D4287L)";
		case MF_E_NET_INVALID_PUSH_TEMPLATE: return "MF_E_NET_INVALID_PUSH_TEMPLATE(0xC00D4288L)";
		case MF_E_NET_INVALID_PUSH_PUBLISHING_POINT: return "MF_E_NET_INVALID_PUSH_PUBLISHING_POINT(0xC00D4289L)";
		case MF_E_NET_BUSY: return "MF_E_NET_BUSY(0xC00D428AL)";
		case MF_E_NET_RESOURCE_GONE: return "MF_E_NET_RESOURCE_GONE(0xC00D428BL)";
		case MF_E_NET_ERROR_FROM_PROXY: return "MF_E_NET_ERROR_FROM_PROXY(0xC00D428CL)";
		case MF_E_NET_PROXY_TIMEOUT: return "MF_E_NET_PROXY_TIMEOUT(0xC00D428DL)";
		case MF_E_NET_SERVER_UNAVAILABLE: return "MF_E_NET_SERVER_UNAVAILABLE(0xC00D428EL)";
		case MF_E_NET_TOO_MUCH_DATA: return "MF_E_NET_TOO_MUCH_DATA(0xC00D428FL)";
		case MF_E_NET_SESSION_INVALID: return "MF_E_NET_SESSION_INVALID(0xC00D4290L)";
		case MF_E_OFFLINE_MODE: return "MF_E_OFFLINE_MODE(0xC00D4291L)";
		case MF_E_NET_UDP_BLOCKED: return "MF_E_NET_UDP_BLOCKED(0xC00D4292L)";
		case MF_E_NET_UNSUPPORTED_CONFIGURATION: return "MF_E_NET_UNSUPPORTED_CONFIGURATION(0xC00D4293L)";
		case MF_E_NET_PROTOCOL_DISABLED: return "MF_E_NET_PROTOCOL_DISABLED(0xC00D4294L)";
		case MF_E_NET_COMPANION_DRIVER_DISCONNECT: return "MF_E_NET_COMPANION_DRIVER_DISCONNECT(0xC00D4295L)";
		case MF_E_ALREADY_INITIALIZED: return "MF_E_ALREADY_INITIALIZED(0xC00D4650L)";
		case MF_E_BANDWIDTH_OVERRUN: return "MF_E_BANDWIDTH_OVERRUN(0xC00D4651L)";
		case MF_E_LATE_SAMPLE: return "MF_E_LATE_SAMPLE(0xC00D4652L)";
		case MF_E_FLUSH_NEEDED: return "MF_E_FLUSH_NEEDED(0xC00D4653L)";
		case MF_E_INVALID_PROFILE: return "MF_E_INVALID_PROFILE(0xC00D4654L)";
		case MF_E_INDEX_NOT_COMMITTED: return "MF_E_INDEX_NOT_COMMITTED(0xC00D4655L)";
		case MF_E_NO_INDEX: return "MF_E_NO_INDEX(0xC00D4656L)";
		case MF_E_CANNOT_INDEX_IN_PLACE: return "MF_E_CANNOT_INDEX_IN_PLACE(0xC00D4657L)";
		case MF_E_MISSING_ASF_LEAKYBUCKET: return "MF_E_MISSING_ASF_LEAKYBUCKET(0xC00D4658L)";
		case MF_E_INVALID_ASF_STREAMID: return "MF_E_INVALID_ASF_STREAMID(0xC00D4659L)";
		case MF_E_STREAMSINK_REMOVED: return "MF_E_STREAMSINK_REMOVED(0xC00D4A38L)";
		case MF_E_STREAMSINKS_OUT_OF_SYNC: return "MF_E_STREAMSINKS_OUT_OF_SYNC(0xC00D4A3AL)";
		case MF_E_STREAMSINKS_FIXED: return "MF_E_STREAMSINKS_FIXED(0xC00D4A3BL)";
		case MF_E_STREAMSINK_EXISTS: return "MF_E_STREAMSINK_EXISTS(0xC00D4A3CL)";
		case MF_E_SAMPLEALLOCATOR_CANCELED: return "MF_E_SAMPLEALLOCATOR_CANCELED(0xC00D4A3DL)";
		case MF_E_SAMPLEALLOCATOR_EMPTY: return "MF_E_SAMPLEALLOCATOR_EMPTY(0xC00D4A3EL)";
		case MF_E_SINK_ALREADYSTOPPED: return "MF_E_SINK_ALREADYSTOPPED(0xC00D4A3FL)";
		case MF_E_ASF_FILESINK_BITRATE_UNKNOWN: return "MF_E_ASF_FILESINK_BITRATE_UNKNOWN(0xC00D4A40L)";
		case MF_E_SINK_NO_STREAMS: return "MF_E_SINK_NO_STREAMS(0xC00D4A41L)";
		case MF_S_SINK_NOT_FINALIZED: return "MF_S_SINK_NOT_FINALIZED(0x000D4A42L)";
		case MF_E_METADATA_TOO_LONG: return "MF_E_METADATA_TOO_LONG(0xC00D4A43L)";
		case MF_E_SINK_NO_SAMPLES_PROCESSED: return "MF_E_SINK_NO_SAMPLES_PROCESSED(0xC00D4A44L)";
		case MF_E_SINK_HEADERS_NOT_FOUND: return "MF_E_SINK_HEADERS_NOT_FOUND(0xC00D4A45L)";
		case MF_E_VIDEO_REN_NO_PROCAMP_HW: return "MF_E_VIDEO_REN_NO_PROCAMP_HW(0xC00D4E20L)";
		case MF_E_VIDEO_REN_NO_DEINTERLACE_HW: return "MF_E_VIDEO_REN_NO_DEINTERLACE_HW(0xC00D4E21L)";
		case MF_E_VIDEO_REN_COPYPROT_FAILED: return "MF_E_VIDEO_REN_COPYPROT_FAILED(0xC00D4E22L)";
		case MF_E_VIDEO_REN_SURFACE_NOT_SHARED: return "MF_E_VIDEO_REN_SURFACE_NOT_SHARED(0xC00D4E23L)";
		case MF_E_VIDEO_DEVICE_LOCKED: return "MF_E_VIDEO_DEVICE_LOCKED(0xC00D4E24L)";
		case MF_E_NEW_VIDEO_DEVICE: return "MF_E_NEW_VIDEO_DEVICE(0xC00D4E25L)";
		case MF_E_NO_VIDEO_SAMPLE_AVAILABLE: return "MF_E_NO_VIDEO_SAMPLE_AVAILABLE(0xC00D4E26L)";
		case MF_E_NO_AUDIO_PLAYBACK_DEVICE: return "MF_E_NO_AUDIO_PLAYBACK_DEVICE(0xC00D4E84L)";
		case MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE: return "MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE(0xC00D4E85L)";
		case MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED: return "MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED(0xC00D4E86L)";
		case MF_E_AUDIO_SERVICE_NOT_RUNNING: return "MF_E_AUDIO_SERVICE_NOT_RUNNING(0xC00D4E87L)";
		case MF_E_AUDIO_BUFFER_SIZE_ERROR: return "MF_E_AUDIO_BUFFER_SIZE_ERROR(0xC00D4E88L)";
		case MF_E_AUDIO_CLIENT_WRAPPER_SPOOF_ERROR: return "MF_E_AUDIO_CLIENT_WRAPPER_SPOOF_ERROR(0xC00D4E89L)";
		case MF_E_TOPO_INVALID_OPTIONAL_NODE: return "MF_E_TOPO_INVALID_OPTIONAL_NODE(0xC00D520EL)";
		case MF_E_TOPO_CANNOT_FIND_DECRYPTOR: return "MF_E_TOPO_CANNOT_FIND_DECRYPTOR(0xC00D5211L)";
		case MF_E_TOPO_CODEC_NOT_FOUND: return "MF_E_TOPO_CODEC_NOT_FOUND(0xC00D5212L)";
		case MF_E_TOPO_CANNOT_CONNECT: return "MF_E_TOPO_CANNOT_CONNECT(0xC00D5213L)";
		case MF_E_TOPO_UNSUPPORTED: return "MF_E_TOPO_UNSUPPORTED(0xC00D5214L)";
		case MF_E_TOPO_INVALID_TIME_ATTRIBUTES: return "MF_E_TOPO_INVALID_TIME_ATTRIBUTES(0xC00D5215L)";
		case MF_E_TOPO_LOOPS_IN_TOPOLOGY: return "MF_E_TOPO_LOOPS_IN_TOPOLOGY(0xC00D5216L)";
		case MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR: return "MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR(0xC00D5217L)";
		case MF_E_TOPO_MISSING_STREAM_DESCRIPTOR: return "MF_E_TOPO_MISSING_STREAM_DESCRIPTOR(0xC00D5218L)";
		case MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED: return "MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED(0xC00D5219L)";
		case MF_E_TOPO_MISSING_SOURCE: return "MF_E_TOPO_MISSING_SOURCE(0xC00D521AL)";
		case MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED: return "MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED(0xC00D521BL)";
		case MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID: return "MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID(0xC00D61ACL)";
		case MF_S_SEQUENCER_CONTEXT_CANCELED: return "MF_S_SEQUENCER_CONTEXT_CANCELED(0x000D61ADL)";
		case MF_E_NO_SOURCE_IN_CACHE: return "MF_E_NO_SOURCE_IN_CACHE(0xC00D61AEL)";
		case MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM: return "MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM(0x000D61AFL)";
		case MF_E_TRANSFORM_TYPE_NOT_SET: return "MF_E_TRANSFORM_TYPE_NOT_SET(0xC00D6D60L)";
		case MF_E_TRANSFORM_STREAM_CHANGE: return "MF_E_TRANSFORM_STREAM_CHANGE(0xC00D6D61L)";
		case MF_E_TRANSFORM_INPUT_REMAINING: return "MF_E_TRANSFORM_INPUT_REMAINING(0xC00D6D62L)";
		case MF_E_TRANSFORM_PROFILE_MISSING: return "MF_E_TRANSFORM_PROFILE_MISSING(0xC00D6D63L)";
		case MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT: return "MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT(0xC00D6D64L)";
		case MF_E_TRANSFORM_PROFILE_TRUNCATED: return "MF_E_TRANSFORM_PROFILE_TRUNCATED(0xC00D6D65L)";
		case MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED: return "MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED(0xC00D6D66L)";
		case MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG: return "MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG(0xC00D6D67L)";
		case MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE: return "MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE(0xC00D6D68L)";
		case MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM: return "MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM(0xC00D6D69L)";
		case MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG: return "MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG(0xC00D6D6AL)";
		case MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE: return "MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE(0xC00D6D6BL)";
		case MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE: return "MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE(0xC00D6D6CL)";
		case MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE: return "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE(0xC00D6D6DL)";
		case MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE: return "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE(0xC00D6D6EL)";
		case MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION: return "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION(0xC00D6D6FL)";
		case MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES: return "MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES(0xC00D6D70L)";
		case MF_E_TRANSFORM_NEED_MORE_INPUT: return "MF_E_TRANSFORM_NEED_MORE_INPUT(0xC00D6D72L)";
		case MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG: return "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG(0xC00D6D73L)";
		case MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING: return "MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING(0xC00D6D74L)";
		case MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT: return "MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT(0x000D6D75L)";
		case MF_E_UNSUPPORTED_D3D_TYPE: return "MF_E_UNSUPPORTED_D3D_TYPE(0xC00D6D76L)";
		case MF_E_TRANSFORM_ASYNC_LOCKED: return "MF_E_TRANSFORM_ASYNC_LOCKED(0xC00D6D77L)";
		case MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER: return "MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER(0xC00D6D78L)";
		case MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION: return "MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION(0xC00D6D79L)";
		case MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED: return "MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED(0xC00D6D7AL)";
		case MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED: return "MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED(0xC00D6D7CL)";
		case MF_E_LICENSE_INCORRECT_RIGHTS: return "MF_E_LICENSE_INCORRECT_RIGHTS(0xC00D7148L)";
		case MF_E_LICENSE_OUTOFDATE: return "MF_E_LICENSE_OUTOFDATE(0xC00D7149L)";
		case MF_E_LICENSE_REQUIRED: return "MF_E_LICENSE_REQUIRED(0xC00D714AL)";
		case MF_E_DRM_HARDWARE_INCONSISTENT: return "MF_E_DRM_HARDWARE_INCONSISTENT(0xC00D714BL)";
		case MF_E_NO_CONTENT_PROTECTION_MANAGER: return "MF_E_NO_CONTENT_PROTECTION_MANAGER(0xC00D714CL)";
		case MF_E_LICENSE_RESTORE_NO_RIGHTS: return "MF_E_LICENSE_RESTORE_NO_RIGHTS(0xC00D714DL)";
		case MF_E_BACKUP_RESTRICTED_LICENSE: return "MF_E_BACKUP_RESTRICTED_LICENSE(0xC00D714EL)";
		case MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION: return "MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION(0xC00D714FL)";
		case MF_S_PROTECTION_NOT_REQUIRED: return "MF_S_PROTECTION_NOT_REQUIRED(0x000D7150L)";
		case MF_E_COMPONENT_REVOKED: return "MF_E_COMPONENT_REVOKED(0xC00D7151L)";
		case MF_E_TRUST_DISABLED: return "MF_E_TRUST_DISABLED(0xC00D7152L)";
		case MF_E_WMDRMOTA_NO_ACTION: return "MF_E_WMDRMOTA_NO_ACTION(0xC00D7153L)";
		case MF_E_WMDRMOTA_ACTION_ALREADY_SET: return "MF_E_WMDRMOTA_ACTION_ALREADY_SET(0xC00D7154L)";
		case MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE: return "MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE(0xC00D7155L)";
		case MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED: return "MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED(0xC00D7156L)";
		case MF_E_WMDRMOTA_ACTION_MISMATCH: return "MF_E_WMDRMOTA_ACTION_MISMATCH(0xC00D7157L)";
		case MF_E_WMDRMOTA_INVALID_POLICY: return "MF_E_WMDRMOTA_INVALID_POLICY(0xC00D7158L)";
		case MF_E_POLICY_UNSUPPORTED: return "MF_E_POLICY_UNSUPPORTED(0xC00D7159L)";
		case MF_E_OPL_NOT_SUPPORTED: return "MF_E_OPL_NOT_SUPPORTED(0xC00D715AL)";
		case MF_E_TOPOLOGY_VERIFICATION_FAILED: return "MF_E_TOPOLOGY_VERIFICATION_FAILED(0xC00D715BL)";
		case MF_E_SIGNATURE_VERIFICATION_FAILED: return "MF_E_SIGNATURE_VERIFICATION_FAILED(0xC00D715CL)";
		case MF_E_DEBUGGING_NOT_ALLOWED: return "MF_E_DEBUGGING_NOT_ALLOWED(0xC00D715DL)";
		case MF_E_CODE_EXPIRED: return "MF_E_CODE_EXPIRED(0xC00D715EL)";
		case MF_E_GRL_VERSION_TOO_LOW: return "MF_E_GRL_VERSION_TOO_LOW(0xC00D715FL)";
		case MF_E_GRL_RENEWAL_NOT_FOUND: return "MF_E_GRL_RENEWAL_NOT_FOUND(0xC00D7160L)";
		case MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND: return "MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND(0xC00D7161L)";
		case MF_E_KERNEL_UNTRUSTED: return "MF_E_KERNEL_UNTRUSTED(0xC00D7162L)";
		case MF_E_PEAUTH_UNTRUSTED: return "MF_E_PEAUTH_UNTRUSTED(0xC00D7163L)";
		case MF_E_NON_PE_PROCESS: return "MF_E_NON_PE_PROCESS(0xC00D7165L)";
		case MF_E_REBOOT_REQUIRED: return "MF_E_REBOOT_REQUIRED(0xC00D7167L)";
		case MF_S_WAIT_FOR_POLICY_SET: return "MF_S_WAIT_FOR_POLICY_SET(0x000D7168L)";
		case MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT: return "MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT(0x000D7169L)";
		case MF_E_GRL_INVALID_FORMAT: return "MF_E_GRL_INVALID_FORMAT(0xC00D716AL)";
		case MF_E_GRL_UNRECOGNIZED_FORMAT: return "MF_E_GRL_UNRECOGNIZED_FORMAT(0xC00D716BL)";
		case MF_E_ALL_PROCESS_RESTART_REQUIRED: return "MF_E_ALL_PROCESS_RESTART_REQUIRED(0xC00D716CL)";
		case MF_E_PROCESS_RESTART_REQUIRED: return "MF_E_PROCESS_RESTART_REQUIRED(0xC00D716DL)";
		case MF_E_USERMODE_UNTRUSTED: return "MF_E_USERMODE_UNTRUSTED(0xC00D716EL)";
		case MF_E_PEAUTH_SESSION_NOT_STARTED: return "MF_E_PEAUTH_SESSION_NOT_STARTED(0xC00D716FL)";
		case MF_E_PEAUTH_PUBLICKEY_REVOKED: return "MF_E_PEAUTH_PUBLICKEY_REVOKED(0xC00D7171L)";
		case MF_E_GRL_ABSENT: return "MF_E_GRL_ABSENT(0xC00D7172L)";
		case MF_S_PE_TRUSTED: return "MF_S_PE_TRUSTED(0x000D7173L)";
		case MF_E_PE_UNTRUSTED: return "MF_E_PE_UNTRUSTED(0xC00D7174L)";
		case MF_E_PEAUTH_NOT_STARTED: return "MF_E_PEAUTH_NOT_STARTED(0xC00D7175L)";
		case MF_E_INCOMPATIBLE_SAMPLE_PROTECTION: return "MF_E_INCOMPATIBLE_SAMPLE_PROTECTION(0xC00D7176L)";
		case MF_E_PE_SESSIONS_MAXED: return "MF_E_PE_SESSIONS_MAXED(0xC00D7177L)";
		case MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED: return "MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED(0xC00D7178L)";
		case MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED: return "MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED(0xC00D7179L)";
		case MF_E_ITA_UNSUPPORTED_ACTION: return "MF_E_ITA_UNSUPPORTED_ACTION(0xC00D717AL)";
		case MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS: return "MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS(0xC00D717BL)";
		case MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS: return "MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS(0xC00D717CL)";
		case MF_E_BAD_OPL_STRUCTURE_FORMAT: return "MF_E_BAD_OPL_STRUCTURE_FORMAT(0xC00D717DL)";
		case MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID: return "MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID(0xC00D717EL)";
		case MF_E_NO_PMP_HOST: return "MF_E_NO_PMP_HOST(0xC00D717FL)";
		case MF_E_ITA_OPL_DATA_NOT_INITIALIZED: return "MF_E_ITA_OPL_DATA_NOT_INITIALIZED(0xC00D7180L)";
		case MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT: return "MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT(0xC00D7181L)";
		case MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT: return "MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT(0xC00D7182L)";
		case MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK: return "MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK(0xC00D7183L)";
		case MF_E_INVALID_AKE_CHANNEL_PARAMETERS: return "MF_E_INVALID_AKE_CHANNEL_PARAMETERS(0xC00D7184L)";
		case MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED: return "MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED(0xC00D7185L)";
		case MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM: return "MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM(0xC00D7186L)";
		case MF_E_DRM_MIGRATION_NOT_SUPPORTED: return "MF_E_DRM_MIGRATION_NOT_SUPPORTED(0xC00D7187L)";
		case MF_E_HDCP_AUTHENTICATION_FAILURE: return "MF_E_HDCP_AUTHENTICATION_FAILURE(0xC00D7188L)";
		case MF_E_HDCP_LINK_FAILURE: return "MF_E_HDCP_LINK_FAILURE(0xC00D7189L)";
		case MF_E_CLOCK_INVALID_CONTINUITY_KEY: return "MF_E_CLOCK_INVALID_CONTINUITY_KEY(0xC00D9C40L)";
		case MF_E_CLOCK_NO_TIME_SOURCE: return "MF_E_CLOCK_NO_TIME_SOURCE(0xC00D9C41L)";
		case MF_E_CLOCK_STATE_ALREADY_SET: return "MF_E_CLOCK_STATE_ALREADY_SET(0xC00D9C42L)";
		case MF_E_CLOCK_NOT_SIMPLE: return "MF_E_CLOCK_NOT_SIMPLE(0xC00D9C43L)";
		case MF_S_CLOCK_STOPPED: return "MF_S_CLOCK_STOPPED(0x000D9C44L)";
		case MF_E_CLOCK_AUDIO_DEVICE_POSITION_UNEXPECTED: return "MF_E_CLOCK_AUDIO_DEVICE_POSITION_UNEXPECTED(0x000D9C45L)";
		case MF_E_CLOCK_AUDIO_RENDER_POSITION_UNEXPECTED: return "MF_E_CLOCK_AUDIO_RENDER_POSITION_UNEXPECTED(0x000D9C46L)";
		case MF_E_CLOCK_AUDIO_RENDER_TIME_UNEXPECTED: return "MF_E_CLOCK_AUDIO_RENDER_TIME_UNEXPECTED(0x000D9C47L)";
		case MF_E_NO_MORE_DROP_MODES: return "MF_E_NO_MORE_DROP_MODES(0xC00DA028L)";
		case MF_E_NO_MORE_QUALITY_LEVELS: return "MF_E_NO_MORE_QUALITY_LEVELS(0xC00DA029L)";
		case MF_E_DROPTIME_NOT_SUPPORTED: return "MF_E_DROPTIME_NOT_SUPPORTED(0xC00DA02AL)";
		case MF_E_QUALITYKNOB_WAIT_LONGER: return "MF_E_QUALITYKNOB_WAIT_LONGER(0xC00DA02BL)";
		case MF_E_QM_INVALIDSTATE: return "MF_E_QM_INVALIDSTATE(0xC00DA02CL)";
		case MF_E_TRANSCODE_NO_CONTAINERTYPE: return "MF_E_TRANSCODE_NO_CONTAINERTYPE(0xC00DA410L)";
		case MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS: return "MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS(0xC00DA411L)";
		case MF_E_TRANSCODE_NO_MATCHING_ENCODER: return "MF_E_TRANSCODE_NO_MATCHING_ENCODER(0xC00DA412L)";
		case MF_E_TRANSCODE_INVALID_PROFILE: return "MF_E_TRANSCODE_INVALID_PROFILE(0xC00DA413L)";
		case MF_E_ALLOCATOR_NOT_INITIALIZED: return "MF_E_ALLOCATOR_NOT_INITIALIZED(0xC00DA7F8L)";
		case MF_E_ALLOCATOR_NOT_COMMITED: return "MF_E_ALLOCATOR_NOT_COMMITED(0xC00DA7F9L)";
		case MF_E_ALLOCATOR_ALREADY_COMMITED: return "MF_E_ALLOCATOR_ALREADY_COMMITED(0xC00DA7FAL)";
		case MF_E_STREAM_ERROR: return "MF_E_STREAM_ERROR(0xC00DA7FBL)";
		case MF_E_INVALID_STREAM_STATE: return "MF_E_INVALID_STREAM_STATE(0xC00DA7FCL)";
		case MF_E_HW_STREAM_NOT_CONNECTED: return "MF_E_HW_STREAM_NOT_CONNECTED(0xC00DA7FDL)";
		case MF_E_NO_CAPTURE_DEVICES_AVAILABLE: return "MF_E_NO_CAPTURE_DEVICES_AVAILABLE(0xC00DABE0L)";
		case MF_E_CAPTURE_SINK_OUTPUT_NOT_SET: return "MF_E_CAPTURE_SINK_OUTPUT_NOT_SET(0xC00DABE1L)";
		case MF_E_CAPTURE_SINK_MIRROR_ERROR: return "MF_E_CAPTURE_SINK_MIRROR_ERROR(0xC00DABE2L)";
		case MF_E_CAPTURE_SINK_ROTATE_ERROR: return "MF_E_CAPTURE_SINK_ROTATE_ERROR(0xC00DABE3L)";
		case MF_E_CAPTURE_ENGINE_INVALID_OP: return "MF_E_CAPTURE_ENGINE_INVALID_OP(0xC00DABE4L)";
		case MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED: return "MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED(0xC00DABE5L)";
		case MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT: return "MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT(0xC00DABE6L)";
		case MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT: return "MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT(0xC00DABE7L)";
		case MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT: return "MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT(0xC00DABE8L)";
		case MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS: return "MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS(0xC00DABE9L)";
		case MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO: return "MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO(0xC00DABEAL)";
		case MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE: return "MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE(0xC00DABEBL)";
		case MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED: return "MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED(0xC00DABECL)";
		case MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT: return "MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT(0xC00DABEDL)";
		case MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE: return "MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE(0xC00DAFC8L)";
		case MF_E_TIMELINECONTROLLER_NOT_ALLOWED: return "MF_E_TIMELINECONTROLLER_NOT_ALLOWED(0xC00DAFC9L)";
		case MF_E_TIMELINECONTROLLER_CANNOT_ATTACH: return "MF_E_TIMELINECONTROLLER_CANNOT_ATTACH(0xC00DAFCAL)";
		case MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED: return "MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED(0xC00DB3B0L)";
		case MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED: return "MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED(0xC00DB3B1L)";
		case MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED: return "MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED(0xC00DB3B2L)";
		case MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID: return "MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID(0xC00DB3B3L)";
		case MF_INDEX_SIZE_ERR: return "MF_INDEX_SIZE_ERR(0x80700001)";
		case MF_NOT_FOUND_ERR: return "MF_NOT_FOUND_ERR(0x80700008)";
		case MF_NOT_SUPPORTED_ERR: return "MF_NOT_SUPPORTED_ERR(0x80700009)";
		case MF_INVALID_STATE_ERR: return "MF_INVALID_STATE_ERR(0x8070000B)";
		case MF_SYNTAX_ERR: return "MF_SYNTAX_ERR(0x8070000C)";
		case MF_INVALID_ACCESS_ERR: return "MF_INVALID_ACCESS_ERR(0x8070000F)";
		case MF_QUOTA_EXCEEDED_ERR: return "MF_QUOTA_EXCEEDED_ERR(0x80700016)";
		case MF_PARSE_ERR: return "MF_PARSE_ERR(0x80700051)";
		case MF_TYPE_ERR: return "MF_TYPE_ERR(0x80704005)";
		}
		char buf[16];
		snprintf(buf, sizeof buf, "(0x%08X)", hr);
		return buf;
	}

	EnumerateDevicesFailed::EnumerateDevicesFailed(const std::string& what) noexcept :
		std::runtime_error(what)
	{
	}

	SetDeviceFailed::SetDeviceFailed(const std::string& what) noexcept :
		std::runtime_error(what)
	{
	}

	SetupFrameBufferFailed::SetupFrameBufferFailed(const std::string& what) noexcept :
		std::runtime_error(what)
	{
	}

	FetchFrameFailed::FetchFrameFailed(const std::string& what) noexcept :
		std::runtime_error(what)
	{
	}

	WebCamTypeInternal::WebCamTypeInternal(OnFrameCBInternalType OnFrameCB, void* Userdata, bool Verbose) :
		OnFrameCB(OnFrameCB),
		Userdata(Userdata),
		Verbose(Verbose)
	{
		if (!CoInitCalled)
		{
			CoInitCalled = SUCCEEDED(CoInitialize(nullptr));
		}
	}

	WebCamTypeInternal::~WebCamTypeInternal()
	{
		// 最后释放前再进一次锁，利用 RAII 减少直接退出前报错率。
		auto lock = std::scoped_lock(*Lock);
	}

	size_t GUID_Hash::operator () (const GUID& g) const
	{
		auto hasher = std::hash<uint32_t>();
		auto data = reinterpret_cast<const uint32_t*>(&g);
		return
			hasher(size_t(data[0]) << 0) +
			hasher(size_t(data[1]) << 2) +
			hasher(size_t(data[2]) << 4) +
			hasher(size_t(data[3]) << 8);
	}

	const std::unordered_map<GUID, ConverterFuncType, GUID_Hash> VideoFormatConverters =
	{
		{ MFVideoFormat_RGB32, TransformImage_RGB32 },
		{ MFVideoFormat_RGB24, TransformImage_RGB24 },
		{ MFVideoFormat_YUY2,  TransformImage_YUY2  },
		{ MFVideoFormat_NV12,  TransformImage_NV12  },
	};

	const std::unordered_map <GUID, RawFrameType, GUID_Hash> VideoFormatEnumMap =
	{
		{ MFVideoFormat_RGB32, RawFrameType::RGB32 },
		{ MFVideoFormat_RGB24, RawFrameType::RGB24 },
		{ MFVideoFormat_YUY2,  RawFrameType::YUY2  },
		{ MFVideoFormat_NV12,  RawFrameType::NV12  },
	};

	std::string GUID2Str(const GUID& g, const std::string& delims)
	{
		if (delims.length() > 2) throw std::invalid_argument("`delims` too long.");
		char buf[256];
		snprintf(buf, sizeof buf, "%08X%s%04X%s%04X%s%02X%02X%02X%02X%02X%02X%02X%02X",
			g.Data1, delims.c_str(),
			g.Data2, delims.c_str(),
			g.Data3, delims.c_str(),
			g.Data4[0], g.Data4[1], g.Data4[2], g.Data4[3],
			g.Data4[4], g.Data4[5], g.Data4[6], g.Data4[7]);
		return buf;
	}

	std::wstring GetDevicePathW(IMFActivate* Device)
	{
		WCHAR* buf = nullptr;
		uint32_t StrSize = 0;
		HRESULT hr = Device->GetAllocatedString(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK, &buf, &StrSize);
		if (FAILED(hr) || !buf) throw EnumerateDevicesFailed(FH(hr) + ": `IMFActivate::GetAllocatedString(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK)` failed.\n");
		auto ret = std::wstring(buf, StrSize);
		CoTaskMemFree(buf);
		return ret;
	}

	std::string GetDevicePath(IMFActivate* Device)
	{
		return std::wstring_convert<std::codecvt_utf8<wchar_t>>().to_bytes(GetDevicePathW(Device));
	}

	EnumeratedDevices::EnumeratedDevices()
	{
		HRESULT hr = S_OK;
		auto Attributes = COMPtr<IMFAttributes>();

		hr = ::MFCreateAttributes(&Attributes, 1);
		if (!SUCCEEDED(hr)) throw EnumerateDevicesFailed(FH(hr) + ": `MFCreateAttributes()` failed.");

		hr = Attributes->SetGUID(
			MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE,
			MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID
		);
		if (!SUCCEEDED(hr)) throw EnumerateDevicesFailed(FH(hr) + ": `Attributes->SetGUID()` failed.");

		hr = ::MFEnumDeviceSources(Attributes, &Devices, &Count);
		if (!SUCCEEDED(hr)) throw EnumerateDevicesFailed(FH(hr) + ": `MFEnumDeviceSources()` failed.");
	}

	EnumeratedDevices::~EnumeratedDevices()
	{
		for (size_t i = 0; i < Count; i++)
		{
			Devices[i]->Release();
		}
		::CoTaskMemFree(Devices);
	}

	STDMETHODIMP WebCamTypeInternal::QueryInterface(const IID& riid, void** v)
	{
		static const QITAB qit[] =
		{
			QITABENT(WebCamTypeInternal, IMFSourceReaderCallback),
			{ 0 },
		};
		return QISearch(this, qit, riid, v);
	}

	STDMETHODIMP_(ULONG) WebCamTypeInternal::AddRef()
	{
		return InterlockedIncrement(&NumRef);
	}

	STDMETHODIMP_(ULONG) WebCamTypeInternal::Release()
	{
		auto ret = InterlockedDecrement(&NumRef);
		if (!NumRef)
		{
			CloseDevice();
		}
		return ret;
	}

	STDMETHODIMP WebCamTypeInternal::OnReadSample(
		HRESULT hrStatus,
		DWORD dwStreamIndex,
		DWORD dwStreamFlags,
		LONGLONG llTimestamp,
		IMFSample* Sample
	)
	{
		COMPtr<IMFMediaBuffer> Buffer = nullptr;
		HRESULT hr = S_OK;

		auto lock = std::scoped_lock(*Lock);

		if (!Sample)
		{
			if (Verbose)
			{
				std::cout << "[WARN] `WebCamTypeInternal::OnReadSample(nullptr)`\n";
			}
			// 即使没获取到帧，依然调用 `OnFrameCB`
			FrameUpdated = false;
			OnFrameCB(Userdata, *this, false);
			return S_OK;
		}
		else
		{
			if (Verbose)
			{
				std::cout << "[INFO] `WebCamTypeInternal::OnReadSample(\"buffer\")`\n";
			}
		}

		// 获取缓冲区
		hr = Sample->GetBufferByIndex(0, &Buffer);
		if (FAILED(hr))
		{
			if (Verbose)
			{
				std::cerr << std::string("[WARN] ") + FH(hr) + ": `Sample->GetBufferByIndex(0, &Buffer)`.\n";
			}
			return hr;
		}

		BYTE* LockPtr = nullptr;
		DWORD MaxLength = 0;
		DWORD CurLength = 0;
		hr = Buffer->Lock(&LockPtr, &MaxLength, &CurLength);
		if (FAILED(hr)) throw FetchFrameFailed(FH(hr) + "Buffer->Lock()");

		FormatConverter(*FrameBuffer, LockPtr, SrcPitch, SrcWidth, SrcHeight);

		hr = Buffer->Unlock();
		if (FAILED(hr)) throw FetchFrameFailed(FH(hr) + "Buffer->Unlock()");

		// 获取到的缓冲区需要释放
		Buffer.reset();

		FrameUpdated = true;
		if (OnFrameCB) OnFrameCB(Userdata, *this, true);
		
		return S_OK;
	}

	STDMETHODIMP WebCamTypeInternal::OnEvent(DWORD, IMFMediaEvent*)
	{
		return S_OK;
	}

	STDMETHODIMP WebCamTypeInternal::OnFlush(DWORD)
	{
		return S_OK;
	}

	bool WebCamTypeInternal::IsReleased()
	{
		return NumRef == 0;
	}

	void WebCamTypeInternal::CloseDevice()
	{
		auto lock = std::scoped_lock(*Lock);
		Reader.reset();
	}

	bool WebCamTypeInternal::IsFormatSupported(REFGUID subtype)
	{
		return VideoFormatConverters.contains(subtype);
	}

	HRESULT WebCamTypeInternal::TryMediaType(IMFMediaType* Type)
	{
		HRESULT hr = S_OK;

		bool Found = false;
		GUID subtype = { 0 };

		hr = Type->GetGUID(MF_MT_SUBTYPE, &subtype);

		if (Verbose)
		{
			std::cout << std::string("[INFO] Testing media type: {") + GUID2Str(subtype, ":") + "}\n";
		}

		if (FAILED(hr)) throw SetDeviceFailed(FH(hr) + ": Type->GetGUID(MF_MT_SUBTYPE) failed.");

		// 是否直接支持
		if (IsFormatSupported(subtype))
		{
			if (Verbose)
			{
				std::cout << "[INFO] The media type is supported directly without conversion needed.\n";
			}
			Found = true;
		}
		else
		{
			// 是否解码后可支持
			for (auto& cvt : VideoFormatConverters)
			{
				hr = Type->SetGUID(MF_MT_SUBTYPE, cvt.first);
				if (FAILED(hr)) throw SetDeviceFailed(FH(hr) + ": Type->SetGUID(MF_MT_SUBTYPE, {" + GUID2Str(cvt.first, ":") + "}) failed.");

				hr = Reader->SetCurrentMediaType(
					MF_SOURCE_READER_FIRST_VIDEO_STREAM,
					NULL,
					Type
				);
				if (SUCCEEDED(hr))
				{
					if (Verbose)
					{
						std::cout << "[INFO] The media type is supported with conversion needed.\n";
					}
					Found = TRUE;
					break;
				}
			}
		}

		if (Found)
		{
			SetupFrameBuffer(Type);
		}

		return hr;
	}

	void WebCamTypeInternal::GetSrcPitch(IMFMediaType* Type, GUID& subtype, uint32_t* SrcPitch)
	{
		HRESULT hr = Type->GetUINT32(MF_MT_DEFAULT_STRIDE, SrcPitch);
		if (SUCCEEDED(hr)) return;

		if (Verbose)
		{
			std::cout << "[WARN] Couldn't get the pitch directly.\n";
		}

		LONG srcPitch;
		hr = MFGetStrideForBitmapInfoHeader(subtype.Data1, SrcWidth, &srcPitch);
		if (FAILED(hr)) throw SetupFrameBufferFailed(FH(hr) + ": `MFGetStrideForBitmapInfoHeader()` failed.");

		if (Verbose)
		{
			std::cout << "[INFO] Using the pitch value from Bitmap Info Header.\n";
		}

		*SrcPitch = uint32_t(srcPitch);
		hr = Type->SetUINT32(MF_MT_DEFAULT_STRIDE, srcPitch);
		if (FAILED(hr)) throw SetupFrameBufferFailed(FH(hr) + ": `Type->SetUINT32(MF_MT_DEFAULT_STRIDE, " + std::to_string(srcPitch) + ")` failed.");
	}

	void WebCamTypeInternal::SetupFrameBuffer(IMFMediaType* Type)
	{
		HRESULT hr = S_OK;
		GUID subtype = { 0 };
		MFRatio PAR = { 0 };

		if (Verbose)
		{
			std::cout << std::string("[INFO] Setting up the framebuffer.\n");
		}

		hr = Type->GetGUID(MF_MT_SUBTYPE, &subtype);
		if (FAILED(hr)) throw SetupFrameBufferFailed(FH(hr) + ": `Type->GetGUID(MF_MT_SUBTYPE)` failed.");

		FormatConverter = VideoFormatConverters.at(subtype);
		CurRawFrameType = VideoFormatEnumMap.at(subtype);

		hr = MFGetAttributeSize(Type, MF_MT_FRAME_SIZE, &SrcWidth, &SrcHeight);
		if (FAILED(hr)) throw SetupFrameBufferFailed(FH(hr) + ": `MFGetAttributeSize(MF_MT_FRAME_SIZE)` failed.");

		FrameBuffer = std::make_shared<Image_RGBA8>(SrcWidth, SrcHeight, Pixel_RGBA8(0, 0, 0, 255));
		
		GetSrcPitch(Type, subtype, &SrcPitch);

		if (Verbose)
		{
			std::cout << std::string("[INFO] The framebuffer is set to ") + std::to_string(SrcWidth) + "x" + std::to_string(SrcHeight) + " with pitch(stride) = " + std::to_string(SrcPitch) + " for source format `" + GetCurRawFrameTypeStr() + "`.\n";
		}
	}

	void WebCamTypeInternal::SetDevice(IMFActivate* Device)
	{
		auto Source = COMPtr<IMFMediaSource>();
		auto Attributes = COMPtr<IMFAttributes>();

		HRESULT hr = S_OK;

		CloseDevice();

		auto lock = std::scoped_lock(*Lock);

		if (Verbose)
		{
			std::wcout << L"[INFO] Set device: " << GetDevicePathW(Device) << "\n";
		}

		// 激活一下
		hr = Device->ActivateObject(
			__uuidof(IMFMediaSource),
			(void**)&Source
		);
		if (!SUCCEEDED(hr)) throw SetDeviceFailed(FH(hr) + ": `Device->ActivateObject()` failed.");

		hr = MFCreateAttributes(&Attributes, 2);
		if (!SUCCEEDED(hr)) throw SetDeviceFailed(FH(hr) + ": `MFCreateAttributes()` failed.");

		hr = Attributes->SetUINT32(MF_READWRITE_DISABLE_CONVERTERS, TRUE);
		if (!SUCCEEDED(hr)) throw SetDeviceFailed(FH(hr) + ": `Attributes->SetUINT32()` failed.");

		// 设置回调接口类
		hr = Attributes->SetUnknown(
			MF_SOURCE_READER_ASYNC_CALLBACK,
			this
		);
		if (!SUCCEEDED(hr)) throw SetDeviceFailed(FH(hr) + ": `Attributes->SetUnknown()` failed.");

		// 设置媒体源
		hr = MFCreateSourceReaderFromMediaSource(
			Source,
			Attributes,
			&Reader
		);
		if (!SUCCEEDED(hr)) throw SetDeviceFailed(FH(hr) + ": `MFCreateSourceReaderFromMediaSource()` failed.");

		// 枚举格式
		for (uint32_t i = 0; ; i++)
		{
			auto Type = COMPtr<IMFMediaType>();
			hr = Reader->GetNativeMediaType(
				MF_SOURCE_READER_FIRST_VIDEO_STREAM,
				i,
				&Type
			);

			// 穷举到最后一种格式类型
			if (FAILED(hr)) { break; }

			// 测试这种格式类型是否支持
			hr = TryMediaType(Type);

			if (SUCCEEDED(hr))
			{
				GUID subtype = { 0 };
				hr = Type->GetGUID(MF_MT_SUBTYPE, &subtype);
				CurRawFrameType = VideoFormatEnumMap.at(subtype);
				break;
			}
		}

		if (FAILED(hr)) throw SetDeviceFailed(FH(hr) + ": `Reader->GetNativeMediaType()`: couldn't find the supported media type.");
	}

	void WebCamTypeInternal::QueryFrame()
	{
		if (Verbose)
		{
			std::cout << "[INFO] Querying a frame.\n";
		}
		HRESULT hr = Reader->ReadSample(
			MF_SOURCE_READER_FIRST_VIDEO_STREAM,
			0,
			NULL,
			NULL,
			NULL,
			NULL
		);
		if (!SUCCEEDED(hr))
		{
			throw EnumerateDevicesFailed(FH(hr) + ": `Reader->ReadSample()` failed.");
		}
	}

	bool WebCamTypeInternal::IsFrameUpdated() const
	{
		return FrameUpdated;
	}

	void WebCamTypeInternal::SetIsFrameUpdated(bool IsUpdated)
	{
		FrameUpdated = IsUpdated;
	}

	RawFrameType WebCamTypeInternal::GetCurRawFrameType() const
	{
		return CurRawFrameType;
	}

	std::string WebCamTypeInternal::GetCurRawFrameTypeStr() const
	{
		return GetRawFrameTypeStr(CurRawFrameType);
	}

	std::string WebCamTypeInternal::GetRawFrameTypeStr(RawFrameType RFT)
	{
		switch (RFT)
		{
		default:
		case RawFrameType::Unknown: return "unknown";
		case RawFrameType::RGB32: return "RGB32";
		case RawFrameType::RGB24: return "RGB24";
		case RawFrameType::YUY2: return "YUY2";
		case RawFrameType::NV12: return "NV12";
		};
	}

	//-------------------------------------------------------------------
	// TransformImage_RGB24 
	//
	// RGB-24 to RGB-32
	//-------------------------------------------------------------------

	void TransformImage_RGB24
	(
		Image_RGBA8& FrameBuffer,
		const BYTE* pSrc, size_t SrcPitch,
		uint32_t Width, uint32_t Height
	)
	{
#pragma omp parallel for
		for (int y = 0; y < int(Height); y++)
		{
			RGBTRIPLE* pSrcPel = (RGBTRIPLE*)(pSrc + y * SrcPitch);
			auto pDestPel = FrameBuffer.GetBitmapRowPtr(y);

			for (int x = 0; x < int(Width); x++)
			{
				pDestPel[x] = Pixel_RGBA8(
					pSrcPel[x].rgbtRed,
					pSrcPel[x].rgbtGreen,
					pSrcPel[x].rgbtBlue,
					255
				);
			}
		}
	}

	//-------------------------------------------------------------------
	// TransformImage_RGB32
	//
	// RGB-32 to RGB-32 
	//
	// Note: This function is needed to copy the image from system
	// memory to the Direct3D surface.
	//-------------------------------------------------------------------

	void TransformImage_RGB32
	(
		Image_RGBA8& FrameBuffer,
		const BYTE* pSrc, size_t SrcPitch,
		uint32_t Width, uint32_t Height
	)
	{
		MFCopyImage(
			reinterpret_cast<BYTE*>(FrameBuffer.GetBitmapDataPtr()), sizeof(Pixel_RGBA8) * FrameBuffer.GetWidth(),
			pSrc, (LONG)SrcPitch,
			Width * 4, Height);
	}

	//-------------------------------------------------------------------
	// TransformImage_YUY2 
	//
	// YUY2 to RGB-32
	//-------------------------------------------------------------------

	void TransformImage_YUY2
	(
		Image_RGBA8& FrameBuffer,
		const BYTE* pSrc, size_t SrcPitch,
		uint32_t Width, uint32_t Height
	)
	{
#pragma omp parallel for
		for (int y = 0; y < int(Height); y++)
		{
			auto pDestPel = FrameBuffer.GetBitmapRowPtr(y);
			uint16_t* pSrcPel = (uint16_t*)(pSrc + y * SrcPitch);

			for (int x = 0; x < int(Width); x += 2)
			{
				// Byte order is U0 Y0 V0 Y1

				int y0 = (int)LOBYTE(pSrcPel[x + 0]);
				int u0 = (int)HIBYTE(pSrcPel[x + 0]);
				int y1 = (int)LOBYTE(pSrcPel[x + 1]);
				int v0 = (int)HIBYTE(pSrcPel[x + 1]);

				pDestPel[x + 0] = ConvertYCrCbToRGB(y0, v0, u0);
				pDestPel[x + 1] = ConvertYCrCbToRGB(y1, v0, u0);
			}
		}
	}

	//-------------------------------------------------------------------
	// TransformImage_NV12
	//
	// NV12 to RGB-32
	//-------------------------------------------------------------------

	void TransformImage_NV12
	(
		Image_RGBA8& FrameBuffer,
		const BYTE* pSrc, size_t SrcPitch,
		uint32_t Width, uint32_t Height
	)
	{
		const BYTE* lpBitsY = pSrc;
		const BYTE* lpBitsCb = lpBitsY + (Height * SrcPitch);
		const BYTE* lpBitsCr = lpBitsCb + 1;

#pragma omp parallel for
		for (int y = 0; y < int(Height); y += 2)
		{
			const BYTE* lpLineY1 = lpBitsY + SrcPitch * (y + 0);
			const BYTE* lpLineY2 = lpBitsY + SrcPitch * (y + 1);
			const BYTE* lpLineCb = lpBitsCb + (y >> 1) * SrcPitch;
			const BYTE* lpLineCr = lpBitsCr + (y >> 1) * SrcPitch;

			auto lpDibLine1 = FrameBuffer.GetBitmapRowPtr(y + 0);
			auto lpDibLine2 = FrameBuffer.GetBitmapRowPtr(y + 1);

			for (int x = 0; x < int(Width); x += 2)
			{
				int  y0 = (int)lpLineY1[0];
				int  y1 = (int)lpLineY1[1];
				int  y2 = (int)lpLineY2[0];
				int  y3 = (int)lpLineY2[1];
				int  cb = (int)lpLineCb[0];
				int  cr = (int)lpLineCr[0];

				lpDibLine1[x + 0] = ConvertYCrCbToRGB(y0, cr, cb);
				lpDibLine1[x + 1] = ConvertYCrCbToRGB(y1, cr, cb);
				lpDibLine2[x + 0] = ConvertYCrCbToRGB(y2, cr, cb);
				lpDibLine2[x + 1] = ConvertYCrCbToRGB(y3, cr, cb);

				lpLineY1 += 2;
				lpLineY2 += 2;
				lpLineCr += 2;
				lpLineCb += 2;
			}
		}
	}
}
